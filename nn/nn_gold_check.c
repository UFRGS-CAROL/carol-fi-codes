#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <math.h>
#include <sys/time.h>
#include <omp.h>

#define REC_LENGTH 49	// size of a record in db
#define REC_WINDOW 10	// number of records to read at a time
#define LATITUDE_POS 28	// location of latitude coordinates in input record
#define OPEN 1000000	// initial value of nearest neighbors

struct neighbor {
    char entry[REC_LENGTH];
    double dist;
};


int compare_neighbor(struct neighbor n1, struct neighbor n2) {
    if (strcmp(n1.entry,n2.entry) != 0)
        return 1;
    if(n1.dist != n2.dist)
        return 1;
    return 0;
}

/**
* This program finds the k-nearest neighbors
* Usage:	./nn <filelist obs: all records in one single file> <num> <target latitude> <target longitude>  <out filename> <gold filename> 
*			filelist: File with the filenames to the records
*			num: Number of nearest neighbors to find
*			target lat: Latitude coordinate for distance calculations
*			target long: Longitude coordinate for distance calculations
* The filelist and data are generated by hurricane_gen.c
* REC_WINDOW has been arbitrarily assigned; A larger value would allow more work for the threads
*/
int main(int argc, char* argv[]) {
    FILE   *flist,*fp;
    int    i=0,j=0, k=0, rec_count=0, done=0;
    //char   sandbox[REC_LENGTH * REC_WINDOW], *rec_iter,*rec_iter2, dbname[64];
    char   *sandbox, *rec_iter,*rec_iter2, dbname[64];
    struct neighbor *neighbors = NULL;
    struct neighbor *neighbors_gold = NULL;
    float target_lat, target_long, tmp_lat=0, tmp_long=0;
    char * gold_filename;
    char * out_filename;

    if(argc < 7) {
        fprintf(stderr, "Invalid set of arguments:\n");
        fprintf(stderr, "%s <filelist obs: all records in one single file> <num> <target latitude> <target longitude>  <out filename> <gold filename>\n",argv[0]);
        exit(-1);
    }


    k = atoi(argv[2]);
    target_lat = atof(argv[3]);
    target_long = atof(argv[4]);
    out_filename = argv[5];
    gold_filename = argv[6];

    neighbors = malloc(k*sizeof(struct neighbor));
    neighbors_gold = malloc(k*sizeof(struct neighbor));

    if(neighbors == NULL) {
        fprintf(stderr, "no room for neighbors\n");
        exit(0);
    }

    printf("#HEADER filename:%s k:%d latitude:%f longitude:%f\n", argv[1], k,target_lat,target_long);


    /******* read gold **********/
    FILE *file;
    if( (file = fopen(gold_filename, "rb" )) == 0 )
        fprintf(stderr, "The GOLD file was not opened\n" );
    for( j = 0 ; j < k ; j++ ) {
        fread(&neighbors_gold[j], sizeof(struct neighbor), 1, file);
    }

    fclose(file);
    if( (file = fopen(out_filename, "rb" )) == 0 )
        fprintf(stderr, "The OUT file was not opened\n" );
    for( j = 0 ; j < k ; j++ ) {
        fread(&neighbors[j], sizeof(struct neighbor), 1, file);
    }
    fclose(file);



    int errors =0;
    char error_detail[300];
    for( j = 0 ; j < k ; j++ ) {
        if( !(neighbors[j].dist == OPEN) ) {
            if(compare_neighbor(neighbors[j], neighbors_gold[j])) {
                errors++;
                if(errors<1000) {
                    sprintf(error_detail," p: [%d], r_d: %1.16e, e_d: %1.16e, r_e: %s, e_e: %s", i, neighbors[j].dist, neighbors_gold[j].dist, neighbors[j].entry, neighbors_gold[j].entry);
                    printf("#ERR %s\n",error_detail);
                }
            }
        }
    }
    printf("#SDC Ite:1 KerTime:0.0 AccTime:0.0 KerErr:%d AccErr:%d\n#END",errors, errors);


    return 0;
}

